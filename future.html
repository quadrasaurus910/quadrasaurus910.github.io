<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pico Cosmic Relay</title>
    <style>
        @keyframes pulse {
            0% {
                    transform: scale(1); /* Original size at the start */
            }
            50% {
                    transform: scale(1.1); /* Slightly larger halfway through */
            }
            100% {
                    transform: scale(1); /* Return to original size at the end */
            }
}
        /* --- Futuristic UI Base --- */
        body {
            background-color: #050510;
            color: #00ffcc;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        h1 { 
            text-shadow: 0 0 10px #00ffcc; 
        }
        
        /* --- The Invisible Trigger --- */
        #secret-trigger {
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            cursor: pointer;
            z-index: 100;
            /* background: rgba(255,0,0,0.2); Uncomment to see the hit-box */
        }

        /* --- The Futuristic Menu Animation --- */
        #cyber-menu {
            position: absolute;
            top: 20px;
            right: 50px;
            width: 0px;        /* Starts at 0 width */
            height: 2px;       /* Starts as a thin line */
            background-color: rgba(0, 30, 50, 0.9);
            border-top: 2px solid #fff; /* The white dash */
            overflow: hidden;
            
            /* The Magic: Width expands first, then Height expands after a 0.4s delay */
            transition: width 0.4s ease-out, height 0.4s ease-out 0.4s, border-color 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.5);
        }

        /* When the 'active' class is added via JavaScript */
        #cyber-menu.active {
            width: 250px;      /* Step 1: Expand right */
            height: 400px;     /* Step 2: Grow down */
            border: 1px solid #00ffcc;
            border-top: 2px solid #fff;
        }

        /* Menu Items fade in AFTER the box is fully drawn (0.8s delay) */
        .menu-content {
            opacity: 0;
            padding: 20px;
            transition: opacity 0.3s ease-in 0.8s;
        }
        #cyber-menu.active .menu-content {
            opacity: 1;
        }

        .menu-item {
            padding: 10px 0;
            border-bottom: 1px solid #004444;
            cursor: pointer;
            background-color: rgba(0, 255, 204, 0.0);
            transition: background-color 0.5s ease; 
        }
        .menu-item:hover,
        .menu-item.active {
            color: #fff; 
            text-shadow: 0 0 8px #fff;
            background-color: rgba(0, 255, 204, 0.7);
            transition: background-color 0.5s ease; 
            animation: pulse 2s infinite;
        }

        .menu-item p {
            margin: 2px 0px 2px 0px;
        }

        /* --- Dashboard Layout --- */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 50px;
        }
        .panel {
            border: 1px solid #004444;
            background: rgba(0, 20, 20, 0.5);
            padding: 15px;
            border-radius: 5px;
        }
        
        /* Live Color Box */
        #current-color {
            width: 100%;
            height: 100px;
            background: #000;
            border: 1px solid #555;
            margin-top: 10px;
            transition: background 0.2s;
        }

        /* Hex Viewer Text */
        #hex-output {
            font-size: 12px;
            color: #aadddd;
            word-wrap: break-word;
            max-height: 150px;
            overflow-y: auto;
        }
        
        button, input[type="file"] {
            background: #002222;
            color: #00ffcc;
            border: 1px solid #00ffcc;
            padding: 10px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover { background: #00ffcc; color: #000; }
    </style>
</head>
<body>

    <div id="secret-trigger"></div>

    <div id="cyber-menu">
        <div class="menu-content">
            <h3 style="margin-top:0; color:#fff;">SYSTEM OVERRIDE</h3>
            <div class="menu-item" id="opt-wave">Enable Wave Manipulation (DCT)</div>
            <div class="menu-item" id="opt-block">Enable Oklab Blocking</div>
            <div class="menu-item">Calibrate Output Stream</div>
            <div class="menu-item">Close Menu</div>
            <div class="menu-item">
                <p>within 1 arcmin of</p>
                <p>position (20h32m18.33s</p>
                <p>41d23m10.6s Equatorial J2000</p>
            </div>
        </div>
    </div>

    <h1>Pico Data Streamer v1.0</h1>
    <input type="file" id="image-upload" accept="image/jpeg, image/png">

    <div class="dashboard">
        <div class="panel">
            <h3>Memory Analysis</h3>
            <p>File Signature: <span id="file-sig">Waiting...</span></p>
            <p>Detected Type: <strong id="file-type" style="color:#fff;">None</strong></p>
            <hr style="border-color:#004444;">
            <h4>Raw Hex Stream (First 64 Bytes)</h4>
            <div id="hex-output">00 00 00 00...</div>
        </div>

        <div class="panel">
            <h3>Live Telemetry</h3>
            <p>RGB Payload: <span id="rgb-val">[0, 0, 0]</span></p>
            <p>Oklab Target: <span id="oklab-val">(0.00, 0.00, 0.00)</span></p>
            <div id="current-color"></div>
            
            <canvas id="image-canvas" style="display:none;"></canvas>
        </div>
    </div>

    <script>
        // --- COLOR SCIENCE & MATH ENGINE ---

// 1. Convert standard Screen RGB (0-255) to Linear RGB (0.0 - 1.0)
function sRGB_to_Linear(val) {
    let v = val / 255.0;
    return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
}

// 2. Convert Linear RGB to Oklab
function linearRGB_to_Oklab(r, g, b) {
    // First convert to XYZ color space
    let l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    let m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    let s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

    let l_ = Math.cbrt(l);
    let m_ = Math.cbrt(m);
    let s_ = Math.cbrt(s);

    return {
        L: 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
        a: 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
        b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_
    };
}

// 3. Convert Oklab back to Linear RGB
function Oklab_to_LinearRGB(L, a, b) {
    let l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    let m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    let s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    let l = l_ * l_ * l_;
    let m = m_ * m_ * m_;
    let s = s_ * s_ * s_;

    let r = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
    let g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
    let b_val = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    // Clamp values between 0.0 and 1.0 to prevent weird hardware flashes
    return {
        r: Math.max(0, Math.min(1, r)),
        g: Math.max(0, Math.min(1, g)),
        b: Math.max(0, Math.min(1, b_val))
    };
}
        // --- 1. Menu Animation Logic ---
        const trigger = document.getElementById('secret-trigger');
        const menu = document.getElementById('cyber-menu');
        
        // Toggle menu on hidden region click
        trigger.addEventListener('click', () => {
            menu.classList.toggle('active');
        });

        // Close menu if clicking the "Close Menu" item
        const menuItems = document.querySelectorAll('.menu-item');
        menuItems[3].addEventListener('click', () => {
            menu.classList.remove('active');
        });

        // --- 2. Memory / Binary Parsing Logic ---
        const fileInput = document.getElementById('image-upload');
        const sigDisplay = document.getElementById('file-sig');
        const typeDisplay = document.getElementById('file-type');
        const hexOutput = document.getElementById('hex-output');

        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Use FileReader to grab the RAW binary memory
            const reader = new FileReader();
            
            reader.onload = function(event) {
                const arrayBuffer = event.target.result;
                const dataView = new DataView(arrayBuffer);
                
                // Read the first 4 bytes to check the magic signature
                let signature = "";
                for (let i = 0; i < 4; i++) {
                    // Convert byte to hex, pad with 0 if needed, and make uppercase
                    signature += dataView.getUint8(i).toString(16).padStart(2, '0').toUpperCase() + " ";
                }
                
                sigDisplay.textContent = signature;

                // Identify File Type based on standard Hex Signatures
                if (signature.startsWith("FF D8 FF")) {
                    typeDisplay.textContent = "JPEG (DCT Wave Compression)";
                    typeDisplay.style.color = "#ffaa00";
                    // Here we would normally unlock the DCT manipulation menu options
                } else if (signature.startsWith("89 50 4E 47")) {
                    typeDisplay.textContent = "PNG (DEFLATE Compression)";
                    typeDisplay.style.color = "#00aaff";
                } else {
                    typeDisplay.textContent = "UNKNOWN FORMAT";
                    typeDisplay.style.color = "#ff0000";
                }

                // Display the first 64 bytes in the Hex Viewer
                let hexDump = "";
                const maxBytes = Math.min(64, dataView.byteLength);
                for (let i = 0; i < maxBytes; i++) {
                    hexDump += dataView.getUint8(i).toString(16).padStart(2, '0').toUpperCase() + " ";
                }
                hexOutput.textContent = hexDump + "...";
                
                // Trigger the canvas image processor
                processImageForLED(file);
            };

            // This reads the file into memory as raw bytes
            reader.readAsArrayBuffer(file); 
        });

        // --- 3. Image Processing & Simulation Bridge ---
        function processImageForLED(file) {
            const canvas = document.getElementById('image-canvas');
            const ctx = canvas.getContext('2d');
            const colorBox = document.getElementById('current-color');
            const rgbText = document.getElementById('rgb-val');
            
            // Create an image object to let the browser handle the heavy decompression
            const img = new Image();
            img.onload = function() {
                // Change these for higher resolution!
                const gridWidth = 64;
                const gridHeight = 64;
                canvas.width = gridWidth;
                canvas.height = gridHeight;
                ctx.drawImage(img, 0, 0, gridWidth, gridHeight);
                
                const imageData = ctx.getImageData(0, 0, gridWidth, gridHeight).data;
                const totalPixels = gridWidth * gridHeight;
                let pixelIndex = 0;
                
                // Hardware Brightness Control (0.0 to 1.0)
                // Set to 0.5 to cut physical LED brightness in half while keeping colors pure
                const MASTER_BRIGHTNESS = 0.6; 
                
                const streamSim = setInterval(() => {
                    if (pixelIndex >= totalPixels) { 
                        clearInterval(streamSim); 
                        return; 
                    }
                    
                    // 1. Get raw sRGB from canvas
                    const sRGB_r = imageData[pixelIndex * 4];
                    const sRGB_g = imageData[pixelIndex * 4 + 1];
                    const sRGB_b = imageData[pixelIndex * 4 + 2];
                    
                    // 2. Convert to Linear RGB
                    const lin_r = sRGB_to_Linear(sRGB_r);
                    const lin_g = sRGB_to_Linear(sRGB_g);
                    const lin_b = sRGB_to_Linear(sRGB_b);
                    
                    // 3. Convert to Oklab for perceptual manipulation
                    let lab = linearRGB_to_Oklab(lin_r, lin_g, lin_b);
                    
                    // 4. Apply Brightness Correction to the L (Lightness) channel
                    lab.L = lab.L * MASTER_BRIGHTNESS;
                    
                    // 5. Convert back to Linear RGB for the hardware
                    const hw_rgb = Oklab_to_LinearRGB(lab.L, lab.a, lab.b);
                    
                    // 6. Scale 0.0-1.0 to 0-255 integers for the Pico
                    const final_R = Math.round(hw_rgb.r * 255);
                    const final_G = Math.round(hw_rgb.g * 255);
                    const final_B = Math.round(hw_rgb.b * 255);
                    
                    // Update the UI
                    document.getElementById('oklab-val').textContent = 
                        `(${lab.L.toFixed(2)}, ${lab.a.toFixed(2)}, ${lab.b.toFixed(2)})`;
                    
                    document.getElementById('rgb-val').textContent = 
                        `[${final_R}, ${final_G}, ${final_B}]`;
                        
                    colorBox.style.background = `rgb(${sRGB_r}, ${sRGB_g}, ${sRGB_b})`; // Show screen color in UI
                    
                    // 7. FIRE TO PICO!
                    const picoIP = "192.168.1.13"; // <--- PUT YOUR PICO IP HERE
                    fetch(`http://${picoIP}/?data=RGB:${final_R},${final_G},${final_B}`, {
                        method: 'GET',
                        mode: 'no-cors' 
                    }).catch(err => {}); // Silently catch errors so it doesn't spam the console
                    
                    pixelIndex++;
                }, 100); // 100ms = 10 frames per second. Drop to 33 for 30fps!
            };
            
            // Read the file again, this time as a Data URL to feed the Image object
            const urlReader = new FileReader();
            urlReader.onload = function(e) { img.src = e.target.result; }
            urlReader.readAsDataURL(file);
        }
    </script>
</body>
</html>
