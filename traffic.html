<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logo Traffic Grid</title>
    <style>
        body {
            background-color: #050505; /* Try #ffffff if you want a white background! */
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            color: white;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            text-shadow: 1px 1px 4px black;
        }
    </style>
</head>
<body>

    <div id="ui">Loading Traffic System...</div>
    <canvas id="trafficCanvas"></canvas>

    <script>
        const canvas = document.getElementById('trafficCanvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('ui');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- CORRIDOR (HIGHWAY) SETUP ---
        // These are the invisible percentage lines where traffic flows (e.g., 20%, 50%, 80% of screen)
        const hLanes = [0.2, 0.5, 0.8]; 
        const vLanes = [0.2, 0.5, 0.8];

        // --- PRE-RENDERING ENGINE (Fixes the Tablet Crash) ---
        // Instead of calculating colors every frame, we "stamp" 12 colored versions into memory once.
        const colorPalette = [];
        const logoImg = new Image();
        logoImg.src = 'logo-complete.png'; 

        function preRenderColors() {
            for (let i = 0; i < 12; i++) {
                const offCanvas = document.createElement('canvas');
                offCanvas.width = 500;
                offCanvas.height = 500;
                const offCtx = offCanvas.getContext('2d');
                
                // Draw base image
                offCtx.drawImage(logoImg, 0, 0, 500, 500);
                
                // Colorize it using source-in (tablet safe!)
                offCtx.globalCompositeOperation = 'source-in';
                offCtx.fillStyle = `hsl(${i * 30}, 100%, 60%)`; // Cycles through the rainbow
                offCtx.fillRect(0, 0, 500, 500);
                
                colorPalette.push(offCanvas);
            }
        }

        // --- THE PARTICLE CLASS ---
        class TrafficLogo {
            constructor() {
                this.reset();
                // Randomize starting positions so they cover the screen immediately
                this.x = (Math.random() * canvas.width * 2) - (canvas.width / 2);
                this.y = (Math.random() * canvas.height * 2) - (canvas.height / 2);
            }

            reset() {
                // 1 = Giant/Close, 6 = Tiny/Far
                this.z = (Math.random() * 5) + 1; 
                this.size = 300 / this.z;

                // YOUR RULE: Cap opacity for giant logos
                this.opacity = 1.0 - (this.z / 6); 
                if (this.size > 150) { 
                    this.opacity = Math.min(this.opacity, 0.35); // Max 35% opacity if huge
                }

                // Pick a pre-colored logo
                this.image = colorPalette[Math.floor(Math.random() * colorPalette.length)];

                this.speed = ((Math.random() * 2) + 0.5) / this.z;

                // Determine Behavior: 70% Vehicular (Grid), 30% Biological (Wavy)
                this.type = Math.random() > 0.3 ? 'vehicular' : 'biological';

                if (this.type === 'vehicular') {
                    // Pick a random lane direction
                    this.direction = Math.random() > 0.5 ? 'H' : 'V';
                    const movingPositive = Math.random() > 0.5 ? 1 : -1;

                    if (this.direction === 'H') {
                        // Snap to a Horizontal Lane
                        this.lanePercentage = hLanes[Math.floor(Math.random() * hLanes.length)];
                        this.y = canvas.height * this.lanePercentage;
                        this.x = movingPositive ? -this.size : canvas.width + this.size;
                        this.vx = this.speed * movingPositive;
                        this.vy = 0;
                    } else {
                        // Snap to a Vertical Lane
                        this.lanePercentage = vLanes[Math.floor(Math.random() * vLanes.length)];
                        this.x = canvas.width * this.lanePercentage;
                        this.y = movingPositive ? -this.size : canvas.height + this.size;
                        this.vx = 0;
                        this.vy = this.speed * movingPositive;
                    }
                } else {
                    // Biological: Wandering off the grid
                    this.x = Math.random() > 0.5 ? -this.size : canvas.width + this.size;
                    this.y = Math.random() * canvas.height;
                    this.vx = (this.speed * (Math.random() > 0.5 ? 1 : -1)) * 0.5;
                    this.vy = 0; // Handled by wave function
                    this.waveAngle = Math.random() * Math.PI * 2;
                    this.waveSpeed = (Math.random() * 0.02) + 0.01;
                    this.waveAmplitude = (Math.random() * 1.5) + 0.5;
                }
            }

            update() {
                // Biological Movement
                if (this.type === 'biological') {
                    this.x += this.vx;
                    this.waveAngle += this.waveSpeed;
                    this.y += Math.sin(this.waveAngle) * this.waveAmplitude;
                } 
                // Vehicular (Grid) Movement
                else {
                    this.x += this.vx;
                    this.y += this.vy;

                    // INTERSECTION LOGIC: Can we turn?
                    if (this.direction === 'H') {
                        // Check if we are crossing a Vertical Lane
                        for (let vLine of vLanes) {
                            let targetX = canvas.width * vLine;
                            // If we hit the exact center of the intersection
                            if (Math.abs(this.x - targetX) < this.speed) {
                                // 20% chance to turn at an intersection
                                if (Math.random() < 0.2) {
                                    this.x = targetX; // Snap to lane center
                                    this.vx = 0;
                                    this.vy = this.speed * (Math.random() > 0.5 ? 1 : -1);
                                    this.direction = 'V';
                                    break;
                                }
                            }
                        }
                    } else if (this.direction === 'V') {
                        // Check if we are crossing a Horizontal Lane
                        for (let hLine of hLanes) {
                            let targetY = canvas.height * hLine;
                            if (Math.abs(this.y - targetY) < this.speed) {
                                if (Math.random() < 0.2) {
                                    this.y = targetY; // Snap to lane center
                                    this.vy = 0;
                                    this.vx = this.speed * (Math.random() > 0.5 ? 1 : -1);
                                    this.direction = 'H';
                                    break;
                                }
                            }
                        }
                    }
                }

                // Out of Bounds check (Allows them to go far off screen to feel like a huge world)
                const margin = this.size * 2;
                if (this.x < -margin || this.x > canvas.width + margin || 
                    this.y < -margin || this.y > canvas.height + margin) {
                    this.reset();
                }
            }

            draw() {
                ctx.globalAlpha = this.opacity;
                // Draw pre-tinted image
                ctx.drawImage(this.image, this.x - this.size/2, this.y - this.size/2, this.size, this.size);
            }
        }

        // --- ANIMATION KEEPER ---
        const fleet = [];
        
        logoImg.onload = () => {
            ui.innerText = ""; // Clear loading text
            preRenderColors(); // Generate our fast colors
            
            // Create 80 logos for traffic
            for (let i = 0; i < 80; i++) {
                fleet.push(new TrafficLogo());
            }
            animate();
        };

        logoImg.onerror = () => {
            ui.innerText = "Error: Could not load logo-complete.png";
        }

        function animate() {
            // Clean clear (No motion blur, safe for light or dark backgrounds!)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sort so small ones draw in back, big ones in front
            fleet.sort((a, b) => b.z - a.z);

            fleet.forEach(logo => {
                logo.update();
                logo.draw();
            });

            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
